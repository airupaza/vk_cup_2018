import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/*B. Переписка с другом
ограничение по времени на тест1 секунда
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Иногда вспоминаешь старого друга и начинаешь вспоминать все, что с ним связано. Хорошо, что есть социальные сети: они хранят вашу переписку с самого знакомства, и можно с легкостью прочитать, о чем же вы спорили 10 лет назад.

Формально, ваша переписка — упорядоченная по времени последовательность сообщений, пронумерованных от 1 до n, где n — общее количество сообщений в переписке.

Каждое сообщение может содержать ссылку на более раннее сообщение, на которое оно является ответом. При открытии сообщения с номером x или при переходе по ссылке на сообщение с номером x диалог показывается так, что видны k сообщений до этого сообщения, само сообщение x и k сообщений после этого сообщения. Если до или после текущего сообщения было менее k сообщений, то все они отображаются.

Изучая старую переписку, вы всегда читаете все сообщения, показанные на экране, а затем переходите по ссылке в текущем сообщении x (в которое пришли по ссылке), если такая есть, и читаете дальше.

Определите количество различных сообщений, которые вы прочтете, если начинать читать переписку, открыв диалог на сообщении t, для каждого t от 1 до n. Считайте ответ для каждого случая независимо. Если начинать читать с сообщения номер x, то на экране изначально показаны k сообщений до сообщения x, само сообщение x и k сообщений после. Сообщения, прочитанные несколько раз, считаются за одно.

Входные данные
В первой строке следуют два целых числа n и k (1 ≤ n ≤ 105, 0 ≤ k ≤ n) — количество сообщений в переписке и количество сообщений, которые видны сверху и снизу от текущего.

Во второй строке следует последовательность целых чисел a1, a2, ..., an (0 ≤ ai < i), где ai равно нулю, если из сообщения i нет ссылки в предыдущее сообщение, либо ai равно номеру сообщения, в которое можно перейти по ссылке из сообщения i. Все сообщения перечислены в хронологическом порядке. Гарантируется, что если в сообщении с номером x есть ссылка, то она ведёт в сообщение с номером меньшим, чем x.

Выходные данные
Выведите n целых чисел, где i-е число должно быть равно количеству различных сообщений, которые можно прочитать, если начинать читать с i-го сообщения и переходить по ссылкам до тех пор, пока это возможно.*/
public class B {
    public static int result(boolean[] mas){ //функция для подсчета прочитанных сообщений
        int sum=0;
        for (boolean x:mas) if (x==true) sum++;
        return sum;
    }
    public static void main(String[] args) throws IOException{
        BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));
        String s1=reader.readLine(); //считываем 1 строку
        String s2=reader.readLine(); // считываем 2 строку
        reader.close();
        String[] first=s1.split(" ");
        String[] second=s2.split(" ");

        if (first.length==2){
            int n=Integer.parseInt(first[0]); //число сообщений n
            int k=Integer.parseInt(first[1]); // кол-во сообщений k которок видно кроме текущего
            int[] mas=new int[n]; // массив для хранения сообщений
            int[] solution=new int[n]; // массив для хранения количества прочитанных сообщений
            boolean[] list=new boolean[n]; // массив где отмечаются какие сообщения были прочитаны
            int test=0;
            for (int x=0;x<list.length;x++) list[x]=false;// все поля false, значит ни одно не прочитано
            if (second.length==n){ //проверяем корректно ли заполнен массив для сообщений и заполянем его
                for (int i=0;i<n;i++) mas[i]=Integer.parseInt(second[i]);

                for (int i=0;i<n;i++){
                    list[i]=true; //текущее сообщение отмечаем как прочитанное
                    if (k!=0) { //если кол-во видимых соолбщений до и после текущего не равно нулю, то
                        if (i-k>=0) for (int j=i-k;j<=i;j++) list[j]=true;
                        else for (int j=0;j<=i;j++) list[j]=true;
                        if (i+k<n) for (int j=i+1;j<=i+k;j++) list[j]=true;
                        else for (int j=i+1;j<n;j++) list[j]=true;
                    }
                    test=mas[i];
                    while (test!=0){ //если сообщение равно нулю, значит оно не ссылается ни на какое сообщение и процесс останавливается
                            test=test-1;
                            list[test]=true;
                        if (k!=0) { //если кол-во видимых соолбщений до и после текущего не равно нулю, то
                            if (test-k>=0) for (int j=test-k;j<=test;j++) list[j]=true;
                            else for (int j=0;j<=test;j++) list[j]=true;
                            if (test+k<n) for (int j=test+1;j<=test+k;j++) list[j]=true;
                            else for (int j=test+1;j<n;j++) list[j]=true;
                        }
                        test=mas[test];
                    }
                    solution[i]=result(list);
                    for (int x=0;x<list.length;x++) list[x]=false;
                }
                for (int i=0;i<n;i++) if (i!=n-1) System.out.print(String.valueOf(solution[i])+" ");
                else System.out.print(solution[i]);
            }

        }
    }
}
